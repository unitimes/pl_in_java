package chessgame;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import chessgame.enums.Constant;
import chessgame.enums.Side;
import chessgame.piece.Bishop;
import chessgame.piece.King;
import chessgame.piece.Knight;
import chessgame.piece.Pawn;
import chessgame.piece.Piece;
import chessgame.piece.Queen;
import chessgame.piece.Rook;
import core.Coordinate;

public class Board {
	Map<Coordinate, Piece> grids;

	public Board() {
		grids = new HashMap<Coordinate, Piece>();
		setGrids();
	}

	// Status Check
	public Boolean isPlaced(Coordinate grid) {
		return grids.containsKey(grid);
	}

	public Boolean isMySide(Coordinate grid, Side side) {
		return grids.get(grid).isYourSide(side);
	}

	public Boolean isAttackable(Coordinate grid, Side side) {
		return isPlaced(grid) && !isMySide(grid, side);
	}

	// Set
	private void setGrids() {
		grids.put(new Coordinate(3, 3), new Pawn(Side.BLACK));
		grids.put(new Coordinate(3, 5), new Pawn(Side.WHITE));
		setFirstRow(Side.BLACK);
		setFirstRow(Side.WHITE);
		setSecondRow(Side.BLACK);
		setSecondRow(Side.WHITE);
	}

	private void setFirstRow(Side side) {
		int row = 0;
		int col = 0;
		if (side == Side.BLACK) {
			row = Constant.MAX_ROW.getNumber() - 1;
		}
		grids.put(new Coordinate(row, col++), new Rook(side));
		grids.put(new Coordinate(row, col++), new Knight(side));
		grids.put(new Coordinate(row, col++), new Bishop(side));
		grids.put(new Coordinate(row, col++), new Queen(side));
		grids.put(new Coordinate(row, col++), new King(side));
		grids.put(new Coordinate(row, col++), new Bishop(side));
		grids.put(new Coordinate(row, col++), new Knight(side));
		grids.put(new Coordinate(row, col), new Rook(side));
	}
	
	private void setSecondRow(Side side) {
		int row = 1;
		if (side == Side.BLACK) {
			row = Constant.MAX_ROW.getNumber() - 2;
		}
		for (int col = 0; col < Constant.MAX_COL.getNumber(); col++) {
			grids.put(new Coordinate(row, col), new Pawn(side));
		}
	}

	// Move

	public Set<Coordinate> searchMovibleGrids(Coordinate piece) {
		return grids.get(piece).searchMovibleGrids(piece, this);
	}

	public void moveTo(Coordinate from, Coordinate to) {
		// Attack code
		if (grids.containsKey(to)) {
			grids.remove(to);
		}

		grids.put(to, grids.get(from));
		grids.remove(from);
	}

	// for test
	public Boolean contain(Coordinate key) {
		return grids.containsKey(key);
	}

	// Print
	public void printGrids() {
		System.out.println(grids.toString());
	}
	
	public void printBoard() {
		for (int row = Constant.MAX_ROW.getNumber() - 1; row >= 0; row--) {
			printRow(row);
		}
	}
	
	private void printRow(int row) {
		for (int col = 0; col < Constant.MAX_COL.getNumber(); col++) {
			printGrid(new Coordinate(row, col));
		}
		System.out.println();
	}
	
	private void printGrid(Coordinate grid) {
		if (grids.containsKey(grid)) {
			System.out.print(grids.get(grid).toString());
			return;
		}
		System.out.print("\u25AD");
	}
}
